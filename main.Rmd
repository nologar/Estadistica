---
title: "Untitled"
output: html_document
date: "2024-11-13"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

En primer lugar, vamos a importar los datos.

```{r}

df<- read.csv("./TG_STAID000455.txt", skip = 20, header = TRUE, sep = ",")
library(lubridate)
df$DATE<- ymd(df$DATE)
```

1. Realizar gráficos que describan la serie original. Comprobar mediante
algún método gráfico si existe estacionalidad anual.

Primero vamos a visualizar la serie temporal.

```{r}

# Gráfico de líneas para la serie temporal
plot(df$DATE, df$TG, type = "l", col = "blue", 
     xlab = "Fecha", ylab = "Temperatura Media (TG)", 
     main = "Evolución de la Temperatura Media")


```
Notamos que esta visualización se debe a los datos perdidos que tenemos en la variable TG. Sabemos que estos están etiquetados con un 9 en la variable Q_TG.

```{r}

head(df[df$Q_TG== 9,])

```

Notamos que los valores perdidos están asociados al valor -9999. Vamos a cambiarlo para que tengan el valor asociado NA.

```{r}

df$TG[df$Q_TG== 9]=NA
head(df[df$Q_TG== 9,])

```

Ahora representamos la serie temporal excluyendo los NA's.

```{r}

library(dplyr)

df_clean <- df %>% na.omit()

plot(df_clean$DATE, df_clean$TG, type = "l", col = "blue", 
     xlab = "Fecha", ylab = "Temperatura Media (TG)", 
     main = "Evolución de la Temperatura Media")



```

También podemos hacer un histograma para analizar la distribución de las temperaturas.

```{r}

# Histograma de la temperatura media
hist(df_clean$TG, breaks = 20, col = "lightblue", 
     xlab = "Temperatura Media (TG)", 
     main = "Distribución de la Temperatura Media")


```

También podemos analizar la dispersión y los posibles outliers con un boxplot.

```{r}

# Boxplot de la temperatura media
boxplot(df_clean$TG, horizontal = TRUE, col = "orange", 
        main = "Dispersión de la Temperatura Media", 
        xlab = "Temperatura Media (TG)")


```
Se pueden observar muchos outliers. Seguramente, la mayoría de ellos serán aquellos valores etiquetados  con un 1 en la variable Q_TG.

```{r}

df[df$Q_TG== 1,]

```

Notamos que efectivamente todos estos valores están fuera de los bigotes del boxplot.

Ahora veremos mediante algún método gráfico si existe estacionalidad anual.

```{r}

df_ts <- ts(df$TG, frequency = 365, start = c(1941, 8))


acf(df_ts, main = "ACF de la Temperatura Media", lag.max = 365 * 10, na.action = na.pass)


```




Este gráfico de autocorrelación nos muestra como está correlacionada la serie temporal consigo misma en diferentes lags de tiempo. Como tenemos datos diarios hemos utilizado lags diarios. Como queremos ver si hay estacionalidad anual, cada unidad del lag representa un año. Por tanto, como podemos observar, hay una clara estacionalidad anual. Esto es de esperar pues estamos hablando de temperatura. Por eso, la autocorrelación aumenta en aquellos puntos en los que la estación sea la misma en distintos años, y disminuye cuando las estaciones sean muy diferentes en temperatura (por ejemplo verano e invierno). Solamente hemos mostrado los diez primeros años para que la visualización sea mejor, pero es suficiente para afirmar que existe estacionalidad en la serie.





2. ¿Parece que hay tendencia? Estimar la tendencia utilizando un modelo
lineal y un filtro de media móvil (teniendo cuidado con los valores NA).
```{r}
library(zoo)

# Cálculo de la media móvil simple
df_clean$TG_ma <- rollmean(df_clean$TG, k = 365, fill = NA)

# Ajuste de un modelo lineal para la tendencia
modelo_lineal <- lm(TG ~ as.numeric(DATE), data = df_clean)

# Gráfico de la serie original, la media móvil y la tendencia
plot(df_clean$DATE, df_clean$TG, type = "l", col = "blue", 
     xlab = "Fecha", ylab = "Temperatura Media (TG)", 
     main = "Evolución de la Temperatura Media")
lines(df_clean$DATE, df_clean$TG_ma, col = "red", lwd = 2)  # Media móvil
abline(modelo_lineal, col = "green", lwd = 2)  # Línea de tendencia del modelo lineal

# Leyenda para identificar las líneas
legend("topright", legend = c("Serie Original", "Media Móvil (k=365)", "Línea de Tendencia (Modelo Lineal)"),
       col = c("blue", "red", "green"), lty = 1)


```

Al contar ahora con la media móvil y el modelo lineal podemos ver que existe una tendencia al alza en los referido a la temperatura media, que va aumentando paulatinamente con los años. Esto no se podía ver en la señal original dado que las distintas estaciones enmascaran esta tendencia.

```{r}
summary(modelo_lineal)
```
Aquí podemos ver algunos de los parámetros más reelevantes del modelo lineal generado.
Los residuos por ejemplo nos indican que existe una gran variedad, lo que se puede deber a la tendencia al alza de las temperaturas a lo largo de los años. Además también podemos ver los parámetros estimados del modelo.

3. Analizar la varianza: ¿parece ser constante?

```{r}
# Como hemos analizado esa estacionalidad anual vamos a relacionar esto con la varianza analizándola de manera anual
df_clean$year <- format(df_clean$DATE, "%Y")

# Calcular varianza por año
var_por_año <- tapply(df_clean$TG, df_clean$year, var)
# Definimos los años 
years<-unique(df_clean$year)
plot(years,var_por_año, type = "b", col = "blue", 
     xlab = "Año", ylab = "Varianza de TG", 
     main = "Varianza de la Temperatura Media por Año")
```

Como vemos la varianza de los datos van variando sin aparente relación. No obstante, vamos a calcular la correlación para estar 100% seguros de esto.
```{r}
# Graficar la autocorrelación de las varianzas anuales
acf(var_por_año, main = "Autocorrelación de las Varianzas Anuales de TG")

```
Como vemos aquí se observan algunos picos aislados pero por lo general el valor de la correlación es cero, lo que es consistente con lo mencionado arriba.



4. Antes de continuar con el análisis, transformar la serie temporal en
una serie regular con una frecuencia fija (el problema es que distintos
años tienen diferentes números de días). Para ello, agregamos la serie
temporal en 36 puntos por año, promediando los días de cada mes en
tres periodos de aproximadamente 10 días. Es decir, para cada mes se
promedian (con la media) las observaciones en tres periodos: desde el 1
hasta el 10, desde el 11 hasta el 20, y desde el 21 hasta el final del mes
(este último periodo puede tener una longitud variable). Las funciones
summarise en combinación con group by del paquete dplyr pueden
ser útiles para esta operación.

Primero, crearemos un nuevo DataFrame con los promedios calculados de cada periodo tal como indica el enunciado.

```{r}

df_avg <- df %>% mutate(day = day(DATE), month= month(DATE), year = year(DATE), period = ifelse(day<=10,'1-10',ifelse(day<=20,'11-20','21-fin'))) %>% # Creamos nuevas columnas con el día, mes, año y los periodos de cada mes
  group_by(year,month,period) %>% # Agrupamos por año, mes y periodo
  summarise(avg_TG = mean(TG, na.rm = TRUE)) %>% # Calculamos el promedio para cada periodo
  ungroup()
  
print(df_avg) 
 
```

Como podemos observar, hay muchos registros que tienen en la columna 'avg_TG' el término NaN. Esto se debe a que en cada uno de los respectivos periodos solo había valores faltantes NA, por eso al calcular el promedio de los valores faltantes el resultado és NaN ('not a number').

A continuación, creamos una serie regular usando los promedios calculados. Como tenemos tres periodos por mes y cada año tiene doce meses tendremos una serie con frecuencia fija 36.

```{r}

df_avg_ts <- ts(df_avg$avg_TG, start = c(min(df_avg$year), min(df_avg$month)), frequency = 36)

plot(df_avg_ts, main = "Serie Temporal Promediada", ylab = "Temperatura Media Promediada", xlab = "Tiempo")

```


5. Descomponer la serie en tendencia, estacionalidad y residuos. Estudiar
los residuos y la tendencia.

Como hemos comentado antes, nuestro DataFrame df_avg tenía valores de tipo NaN, por tanto, nuestra serie temporal df_avg_ts también los tiene. Además, se puede observar en df_avg que estos valores faltantes están muy juntos. En 1942, tenemos todos los periodos desde el segundo mes hasta el octavo lleno de valores faltantes. Además, desde el décimo mes hasta el fin de año también tenemos todos los periodos llenos de NaN. Esto provoca que prácticamente todo el año 1942 esté sin registros. Esto puede suponer un problema para este ejercicio, ya que queremos analizar la serie descomponiéndola en tendencia, estacionalidad y residuos, y para esta tarea necesitamos tener una serie continua. Para solventar este problema pensamos que la mejor solución es la imputación, ya que con la eliminación perderíamos casi todos los registros de un año entero. Para realizar la imputación, utilizaremos la función 'na.seasplit' de la librería 'imputeTS', que basa la imputación en patrones estacionales. Como hemos probado que nuestra serie tiene estacionalidad anual, esta función imputa los valores faltantes basándose en los datos de otros años en los mismos meses o periodos.  


```{r}

require(imputeTS)

# Imputar valores faltantes respetando estacionalidad
df_avg_ts_clean <- na_seasplit(df_avg_ts)

# Descomponemos la serie en tendencia, estacionalidad y residuos.

serie_desc <- decompose(df_avg_ts_clean)

plot(serie_desc)
```
Primero vamos a analizar los residuos. Los residuos deberían ser cercanos a ruido blanco, es decir, no deberían mostrar patrones claros ni autocorrelación significativa. 

```{r}

# Graficar los residuos
plot(serie_desc$random, main = "Residuos de la serie temporal", ylab = "Residuos", xlab = "Tiempo")

# Autocorrelación de los residuos
acf(na.omit(serie_desc$random), main = "ACF de los residuos")

```

Notamos que a simple vista los residuos sí que se asemejan a ruido blanco. Para estar seguros, hemos echo un gráfico de autocorrelación. Como era de esperar no parece haber una autocorrelación significativa en los residuos.

A continuación analizaremos la tendencia.

```{r}

# Graficar la tendencia
plot(serie_desc$trend, main = "Tendencia de la serie temporal", ylab = "Tendencia", xlab = "Tiempo")

```

Se puede observar que la serie tiene una clara tendencia creciente.

6. ¿Hay evidencia del cambio clim´atico en estas observaciones? Es decir,
¿parece haber un calentamiento a lo largo del tiempo? Responder analizando la informaci´on obtenida hasta ahora y, eventualmente, utilizando
otros m´etodos.
```{r}
# Graficar la tendencia
plot(serie_desc$trend, main = "Tendencia de la serie temporal", ylab = "Tendencia", xlab = "Tiempo")
```
Con el gráfico de la tendencia podemos observar el efecto del cambio climático, ya que muestra una tendencia ascendente claramente definida. Esto indica que, desde 1940 hasta 2024, ha habido un cambio significativo en la temperatura de aproximadamente 4 grados Celsius (40 décimas de grado Celsius). Esta variación refleja un patrón que es consistente con el calentamiento global, caracterizado por un aumento progresivo de las temperaturas a lo largo de las últimas décadas.

7. Considerando la informaci´on hasta el a˜no 2010, construir un modelo
predictivo para la temperatura en la d´ecada 2010-2020. Contrastar la
predicci´on obtenida con los datos observados. Comparar distintos modelos predictivos y evaluarlos en cuanto a su capacidad para predecir
la temperatura de la d´ecada 2010-2020.

El modelo más simple que pueda considerarse se basa en descomponer la serie temporal en tendencia, estacionalidad y ruido, hacer una predición de la tendencia mediante un modelo lineal y después añadir la estacionalidad correspondiente y un ruido aleatorio. 

Para aprovechar el trabajo previo, trabajaremos directamente sobre la serie temporal que calcula las medias en intervalos de ~10 días

Consideramos en primer lugar el dataframe que contiene la descomposición hasta el año 2010:

Como la la tendencia de la serie es calculada a partir de enero de 1941 entonces sabemos que el número de entradas que hay hasta enero de 2010 serán $(3\cdot 12) \cdot (2010-1941+1)$
```{r}
times_vec <- seq(1940,2010-1/36, by = 1/36)

df_hasta_2010<- data.frame( time = times_vec, trend = serie_desc$trend[1:(36* (2010-1941+1))] , seasonal = serie_desc$seasonal[1:(36* (2010-1941+1))], random = serie_desc$random[1:(36* (2010-1941+1))])

par(mfrow = c(3,1))
plot( df_hasta_2010$time,  df_hasta_2010$trend, type = "l", main = "Tendencia hasta 2010", xlab = "Año", ylab = "Temperatura (F)")
plot( times_vec,  estacion_hasta_2010, type = "l", main = "Estacionalidad hasta 2010", xlab = "Año", ylab = "Temperatura (F)")
plot( times_vec,  ruido_hasta_2010, type = "l", main = "Ruido hasta 2010", xlab = "Año", ylab = "Temperatura (F)")
```
Procedemos ahora con el estudio previamente explicado: generamos un modelo lineal para la tendencia:

```{r}
modelo_tendencia<- lm()
```



8. Proporcionar una estimaci´on de la temperatura hasta el a˜no 2030. En
particular, proporcionar una estimaci´on de la temperatura para todos
los meses del a˜no 2030. Utilizar el mejor modelo obtenido en el punto
anterior. Intentar tambi´en proporcionar una estimaci´on de la confianza
o incertidumbre de las predicciones.
