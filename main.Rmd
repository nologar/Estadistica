---
title: "Untitled"
output: html_document
date: "2024-11-13"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

En primer lugar, vamos a importar los datos.

```{r}

df<- read.csv("./TG_STAID000455.txt", skip = 20, header = TRUE, sep = ",")
library(lubridate)
df$DATE<- ymd(df$DATE)
```

1. Realizar gráficos que describan la serie original. Comprobar mediante
algún método gráfico si existe estacionalidad anual.

Primero vamos a visualizar la serie temporal.

```{r}

# Gráfico de líneas para la serie temporal
plot(df$DATE, df$TG, type = "l", col = "blue", 
     xlab = "Fecha", ylab = "Temperatura Media (TG)", 
     main = "Evolución de la Temperatura Media")


```
Notamos que esta visualización se debe a los datos perdidos que tenemos en la variable TG. Sabemos que estos están etiquetados con un 9 en la variable Q_TG.

```{r}

head(df[df$Q_TG== 9,])

```

Notamos que los valores perdidos están asociados al valor -9999. Vamos a cambiarlo para que tengan el valor asociado NA.

```{r}

df$TG[df$Q_TG== 9]=NA
head(df[df$Q_TG== 9,])

```

Ahora representamos la serie temporal excluyendo los NA's.

```{r}

library(dplyr)

df_clean <- df %>% na.omit()

plot(df_clean$DATE, df_clean$TG, type = "l", col = "blue", 
     xlab = "Fecha", ylab = "Temperatura Media (TG)", 
     main = "Evolución de la Temperatura Media")



```

También podemos hacer un histograma para analizar la distribución de las temperaturas.

```{r}

# Histograma de la temperatura media
hist(df_clean$TG, breaks = 20, col = "lightblue", 
     xlab = "Temperatura Media (TG)", 
     main = "Distribución de la Temperatura Media")


```

También podemos analizar la dispersión y los posibles outliers con un boxplot.

```{r}

# Boxplot de la temperatura media
boxplot(df_clean$TG, horizontal = TRUE, col = "orange", 
        main = "Dispersión de la Temperatura Media", 
        xlab = "Temperatura Media (TG)")


```
Se pueden observar muchos outliers. Seguramente, la mayoría de ellos serán aquellos valores etiquetados  con un 1 en la variable Q_TG.

```{r}

df[df$Q_TG== 1,]

```

Notamos que efectivamente todos estos valores están fuera de los bigotes del boxplot.

Ahora veremos mediante algún método gráfico si existe estacionalidad anual.

```{r}

df_ts <- ts(df$TG, frequency = 365, start = c(1941, 8))


acf(df_ts, main = "ACF de la Temperatura Media", lag.max = 365 * 10, na.action = na.pass)


```




Este gráfico de autocorrelación nos muestra como está correlacionada la serie temporal consigo misma en diferentes lags de tiempo. Como tenemos datos diarios hemos utilizado lags diarios. Como queremos ver si hay estacionalidad anual, cada unidad del lag representa un año. Por tanto, como podemos observar, hay una clara estacionalidad anual. Esto es de esperar pues estamos hablando de temperatura. Por eso, la autocorrelación aumenta en aquellos puntos en los que la estación sea la misma en distintos años, y disminuye cuando las estaciones sean muy diferentes en temperatura (por ejemplo verano e invierno). Solamente hemos mostrado los diez primeros años para que la visualización sea mejor, pero es suficiente para afirmar que existe estacionalidad en la serie.





2. ¿Parece que hay tendencia? Estimar la tendencia utilizando un modelo
lineal y un filtro de media móvil (teniendo cuidado con los valores NA).



3. Analizar la varianza: ¿parece ser constante?




4. Antes de continuar con el análisis, transformar la serie temporal en
una serie regular con una frecuencia fija (el problema es que distintos
años tienen diferentes números de días). Para ello, agregamos la serie
temporal en 36 puntos por año, promediando los días de cada mes en
tres periodos de aproximadamente 10 días. Es decir, para cada mes se
promedian (con la media) las observaciones en tres periodos: desde el 1
hasta el 10, desde el 11 hasta el 20, y desde el 21 hasta el final del mes
(este último periodo puede tener una longitud variable). Las funciones
summarise en combinación con group by del paquete dplyr pueden
ser útiles para esta operación.

Primero, crearemos un nuevo DataFrame con los promedios calculados de cada periodo tal como indica el enunciado.

```{r}

df_avg <- df %>% mutate(day = day(DATE), month= month(DATE), year = year(DATE), period = ifelse(day<=10,'1-10',ifelse(day<=20,'11-20','21-fin'))) %>% # Creamos nuevas columnas con el día, mes, año y los periodos de cada mes
  group_by(year,month,period) %>% # Agrupamos por año, mes y periodo
  summarise(avg_TG = mean(TG, na.rm = TRUE)) %>% # Calculamos el promedio para cada periodo
  ungroup()
  
print(df_avg) 

```

A continuación, creamos una serie regular usando los promedios calculados. Como tenemos tres periodos por mes y cada año tiene doce meses tendremos una serie con frecuencia fija 36.

```{r}

df_avg_ts <- ts(df_avg$avg_TG, start = c(min(df_avg$year), min(df_avg$month)), frequency = 36)

plot(df_avg_ts, main = "Serie Temporal Promediada", ylab = "Temperatura Media Promediada", xlab = "Tiempo")

```


5. Descomponer la serie en tendencia, estacionalidad y residuos. Estudiar
los residuos y la tendencia.


6. ¿Hay evidencia del cambio clim´atico en estas observaciones? Es decir,
¿parece haber un calentamiento a lo largo del tiempo? Responder analizando la informaci´on obtenida hasta ahora y, eventualmente, utilizando
otros m´etodos.


7. Considerando la informaci´on hasta el a˜no 2010, construir un modelo
predictivo para la temperatura en la d´ecada 2010-2020. Contrastar la
predicci´on obtenida con los datos observados. Comparar distintos modelos predictivos y evaluarlos en cuanto a su capacidad para predecir
la temperatura de la d´ecada 2010-2020.


8. Proporcionar una estimaci´on de la temperatura hasta el a˜no 2030. En
particular, proporcionar una estimaci´on de la temperatura para todos
los meses del a˜no 2030. Utilizar el mejor modelo obtenido en el punto
anterior. Intentar tambi´en proporcionar una estimaci´on de la confianza
o incertidumbre de las predicciones.
